## 5.1 引言 (Introduction)

本章依据 IEEE 1016 标准及第 3 章确立的概念模型，从设计视角对 FitnessAI 智能健身助手系统的内部结构与技术实现进行详细规约。作为软件设计说明书的核心部分，本章旨在将软件需求规格说明书中的功能与非功能需求，转化为可落地的软件架构与组件设计，明确系统在静态结构、动态行为及数据组织上的具体形态。

### 5.1.1 设计目标与策略

FitnessAI 的设计紧密围绕 **3.1.2 节** 所定义的关键设计关注点展开。针对“实时性能与低延迟响应”的约束，本设计采用了 **端侧计算为主、云端编排为辅** 的策略，将姿态识别与实时纠错闭环下沉至前端浏览器环境，以确保满足高频交互下的低延迟要求；针对“数据安全与隐私保护”的约束，设计上确立了 **数据最小化流转** 原则，严格界定原始视频流与抽象关键点数据的边界，确保敏感数据不越过前端边界。同时，为响应“模块化与可维护性”要求，系统后端被设计为无状态的业务编排中枢，通过 RESTful API 契约与前端及数据层解耦。

### 5.1.2 设计视角的组织

为全面、清晰地表达 FitnessAI 的设计方案，本章采用多视角描述方法，涵盖以下维度：

- **上下文视角（Context Viewpoint）：** 承接 **3.1.1 节** 定义的设计边界，进一步明确系统与终端用户、浏览器运行时环境、外部算法库（MediaPipe, TensorFlow.js）及硬件设备（摄像头、GPU）之间的交互界面与数据 I/O 关系。（详见 **5.2 节**）
    
- **组合视角（Composition Viewpoint）：** 描述系统的物理分解结构，重点阐述前端应用容器（React SPA）、后端服务容器（Flask RESTful API）与数据库组件（PostgreSQL）的装配关系，以及各子系统在“前后端分离”架构下的职责划分与部署拓扑。（详见 **5.3 节**）
    
- **逻辑视角（Logical Viewpoint）：** 定义系统的静态功能结构，通过类图与包图展示核心领域实体（如 `Session`, `Exercise`, `AnalysisResult`）的属性、方法及关联关系。重点描述姿态分析模块的 **策略模式** 实现（`PoseAnalyzer` 抽象基类及其具体运动子类），确保业务语义在代码层面的一致性。（详见 **5.4 节**）
    
- **依赖视角（Dependency Viewpoint）：** 分析模块间的调用依赖及对关键第三方组件（如 MediaPipe 0.10.x, Flask 2.3.x, PostgreSQL 14+）的版本约束与兼容性要求，为构建管理（Build Management）与变更影响分析提供依据。（详见 **5.5 节**）
    
- **信息视角（Information Viewpoint）：** 针对 **3.1.2 节** 中的数据一致性关注点，详细规约基于 PostgreSQL 的持久化存储策略。特别是针对非结构化运动数据（如 `Session.scores`, `User.profile`）采用 **JSONB** 字段存储，与结构化业务数据（如账户、鉴权信息）共存的混合存储模型设计。（详见 **5.6 节**）
    
- **设计模式使用视角（Patterns Use Viewpoint）：** 说明系统中采用的关键设计模式，包括 **策略模式**（封装不同运动类型的分析算法）、**工厂模式**（动态创建分析器实例）及 **仓储模式**（Repository 层封装数据访问），以验证设计在应对未来运动类型扩展（**3.1.2 可扩展性关注点**）时的演化能力。（详见 **5.7 节**）

# 5.2 上下文视角 (Context Viewpoint)

本节承接 3.1.1 节定义的设计边界，将 FitnessAI 系统视为一个完整的**黑盒实体**，重点描述系统边界、外部交互实体以及跨越边界的数据流转契约。本视角不涉及系统内部的组件划分（相关内容见 5.3 组合视角），而是聚焦于系统作为一个整体如何嵌入到其运行环境中。

## 5.2.1 系统边界定义 

FitnessAI 系统的边界圈定了所有由本设计负责实现的软件组件。

- **系统内部 ：所有待开发的软件资产，包括运行在浏览器端的前端业务逻辑、WASM 推理模块，以及运行在云端的后端服务和数据库。
    
- **系统外部：
    
    - **宿主环境**：标准的 Web 浏览器运行时（提供 WebRTC, Canvas, Network 能力）。
        
    - **硬件环境**：用户设备的摄像头（Video Source）和 GPU（Compute Resource）。
        
    - **外部服务**：Zhipu AI (GLM) 认知服务接口。
        

## 5.2.2 外部实体与交互

系统与以下四个外部实体进行交互：

### 5.2.2.1 终端用户 

用户是系统的核心服务对象和主动触发者。

- **输入**：
    
    - **物理层**：连续的肢体运动（系统通过摄像头被动捕获）。
        
    - **逻辑层**：GUI 控制指令（开始、暂停、调整目标）。
        
- **输出**：
    
    - **实时反馈**：<100ms 延迟的骨骼可视化覆盖层与计数反馈。
        
    - **训练报告**：训练结束后生成的自然语言建议与图表。
        

### 5.2.2.2 浏览器运行时

这是前端代码的“宿主容器”，系统完全依赖其提供的标准 Web API 能力，不直接调用操作系统内核。

- **职责**：提供硬件抽象层（HAL）和安全沙箱。
    
- **关键依赖接口**：
    
    - `MediaDevices.getUserMedia()`：请求摄像头数据流。
        
    - `WebGL / WebAssembly`：提供底层算力支持本地 AI 推理。
        
    - `Fetch API`：提供网络传输能力。
        

### 5.2.2.3 物理传感器 

- **角色**：原始数据源。
    
- **约束**：系统要求传感器提供分辨率 $\ge$ 640x480 @ 30fps 的 RGB 视频流。
    

### 5.2.2.4 外部智能服务

- **角色**：增强型认知引擎（AI Coach）。
    
- **交互**：系统后端作为客户端，向 Zhipu AI 发送脱敏的统计数据，接收文本建议。
    

## 5.2.3 上下文交互图 

下图展示了 FitnessAI System 作为中心节点，与其运行环境及外部实体的交互拓扑。系统作为黑盒，通过标准接口与外部世界交换信息。
![上下文交互图](./pictures/Pasted%20image%20251226205520.png)
图5-1 上下文交互图
箭头表示数据或控制流的方向，标注文字说明了交互的主要内容。
## 5.2.4 外部接口契约 
系统对外暴露或依赖的接口契约如下，重点关注跨越系统边界的数据交换。

|**外部实体**|**交互界面**|**协议/标准**|**数据流向**|**备注**|
|---|---|---|---|---|
|**User**|GUI / Visual|HCI|双向|视觉反馈闭环|
|**Browser**|Web Standard|W3C WebRTC / WASM|双向|获取流/调用算力|
|**Zhipu AI**|API Endpoint|HTTPS / OpenAPI|Out/In|请求生成建议|

跨边界数据载荷 (Payload) 示例：
当系统与 Zhipu AI 交互时，系统（后端）将发送如下脱敏的 JSON 数据包，此数据包已跨越了系统边界：
JSON
```
{
  "request_type": "training_summary",
  "data": {
    "exercise": "squat",
    "metrics": {
      "total_reps": 15,
      "accuracy_rate": 85.5,
      "major_faults": ["knee_valgus"]
    },
    // 注意：此处不包含任何用户PII（个人身份信息）
    "user_level": "beginner" 
  }
}
```


# 5.3 组合视角 (Composition Viewpoint)

本节采用**白盒视角**，打开 5.2 节定义的系统边界，详细解构 FitnessAI 系统的内部物理组件及其装配关系。系统遵循 **C4 模型** 的层级分解原则，将系统分解为独立部署的子系统和内部功能模块。

## 5.3.1 系统分解策略

FitnessAI 采用**分层架构**与**前后端分离**的分解策略，依据**高内聚、低耦合**的设计原则将系统划分为三个主要子系统。这种分解策略旨在应对低延迟交互、复杂业务逻辑与数据灵活性的需求。

![系统容器图](./pictures/Pasted%20image%20251226205804.png)

图5-2 系统容器图 
## 5.3.2 子系统分解与职责

### 5.3.2.1 前端应用子系统

前端应用不仅仅是 UI，更是一个包含感知、推理与决策的**智能富客户端**。它基于 React + TypeScript 构建，内部组件围绕**“实时推理流”**进行组织。为了实现毫秒级的动作反馈，前端设计采用了**流水线模式**。下图展示了从摄像头原始帧采集到最终 UI 呈现的完整数据流向，重点体现了 `MediaPipeAdapter` 如何作为核心引擎驱动整个感知链路。

![前端数据流图](./pictures/Pasted%20image%20251226214908.png)
图5-3 系统容器图 
#### 1. 表示层模块

**职责**：负责页面渲染、Canvas 绘图及用户交互事件捕获。

- **App Container**：应用根容器，集成 React Context 进行全局状态注入（如 AuthToken）。
    
- **CameraOverlay**：核心视图组件，采用**分层渲染策略**——底层显示原始视频流，上层透明 Canvas 绘制骨骼连线，避免重绘开销。
    
- **StatsDashboard**：实时仪表盘，通过**观察者模式**订阅分析状态流，以 30fps 频率无闪烁刷新计数与得分。
    

#### 2. 核心业务逻辑模块

**职责**：前端的大脑，封装姿态检测生命周期与状态管理。

- **usePoseDetection Hook**：作为**控制器**，协调输入源、适配器和视图层之间的协作。维护 `isDetecting`（检测状态）、`currentRepCount`（计数）等瞬时状态。
    
- **Telemetry Buffer**：数据缓冲组件。为了防止高频 HTTP 请求阻塞主线程，该组件暂存每帧分析结果，按批次打包发送给后端。
    

#### 3. 边缘计算集成模块

**职责**：屏蔽底层 AI 算法库的复杂性，提供标准化的推理接口。

- **MediaPipe Adapter**：单例模式组件，管理 WASM 二进制文件的加载与内存释放。
    
- **Motion Analyzer Strategy**：采用**策略模式**实现。定义统一接口 `analyze()`，具体策略包括 `SquatStrategy`（深蹲几何计算）、`PlankStrategy`（直线度检测）等。
    

### 5.3.2.2 后端服务子系统

后端服务子系统是系统的**业务中枢**，基于 Flask 框架构建，采用经典的**三层架构**设计，强调关注点分离。后端架构的核心目标是**高内聚与低耦合**。通过下方的分层结构图可以看到，系统将复杂的 AI 代理逻辑（Advisor Agent）与基础的 CRUD 业务进行了物理隔离，确保了业务逻辑的纯粹性与外部服务接入的灵活性。
![后端分层架构图](./pictures/Pasted%20image%20251226215459.png)
图5-4 后端分层架构图

#### 1. 接口层

**职责**：流量入口，处理 HTTP 协议解析、参数校验与响应格式化。

- **SessionController**：处理遥测数据上传。
    
- **AnalysisController**：处理同步分析请求（如请求后端深度学习模型复核）。
    

#### 2. 业务逻辑层

**职责**：纯粹的业务规则实现，不依赖 HTTP 或 SQL 细节。

- **Pose Analysis Engine**：执行复杂分析逻辑。
    
    - **SquatClassifier**：封装 TensorFlow 运行时。加载模型，输入特征向量，输出动作状态分类及置信度，用于校准前端规则引擎。
        
- **Advisor Agent**：作为**智谱 AI**的代理客户端。负责将结构化的训练统计数据转换为 Prompt，调用大模型 API，并将返回文本清洗为标准格式。
    

#### 3. 数据访问层

**职责**：封装数据库操作，实现数据访问与业务逻辑解耦。

- **SessionRepository**：封装对会话表的操作。实现对 **JSONB** 字段的高效查询逻辑。
    

### 5.3.2.3 数据持久化子系统
本系统的数据模型旨在兼顾“用户关系”的严谨性与“运动遥测”的灵活性。下图的 ER 模型（图表 5-5）展示了系统如何利用 PostgreSQL 的 **对象-关系（Object-Relational）** 特性，构建混合存储架构。
![实体关系图](./pictures/Pasted%20image%20251226220137.png)
图5-5 实体关系图
**职责**：提供可靠、可扩展的数据存储，并支撑 AI 业务的数据闭环。

**组件**：PostgreSQL 实例。

**混合数据模型设计**：

- **基础数据区域（结构化）**：
    
    - `users` 表：存储账号与鉴权信息，保证事务的 **ACID** 属性。
        
    - `exercises` 表：作为系统的**元数据字典**，标准化定义各类运动的参数（如难度、标准视频 URL），支持业务逻辑的动态配置。
        
- **业务数据区域（半结构化 JSONB）**：
    
    - `sessions` 表：核心业务表。利用 **JSONB** 字段 (`telemetry_log`) 存储高维度的动作时序数据与骨骼快照，避免了因运动类型差异导致的频繁表结构变更。
        
    - `training_plans` 表：存储智谱 AI 生成的长期训练计划 (`schedule_json`)。由于 AI 生成内容的结构多变，使用 JSONB 存储能最大程度保留数据的灵活性。
        

## 5.3.3 动态组合场景

本小节描述在核心业务场景下，上述组件如何通过协作完成任务。为了验证“边缘推理”的低延迟特性，我们需要观察组件间的动态交互。下方的时序图刻画了在一次典型的深蹲动作中，前端各模块如何实现完全无需服务器参与的自闭环反馈。
![实时分析闭环时序图](./pictures/Pasted%20image%20251226215732.png)

图5-6 实时分析闭环时序图
### 5.3.3.1 场景一：实时动作分析闭环

此场景展示了前端组件如何形成毫秒级响应闭环，无需后端介入。

1. **VideoSource** 捕获图像帧，传递给 **MediaPipeAdapter**。
    
2. **MediaPipeAdapter** 在 WASM 中执行推理，输出关键点。
    
3. **usePoseDetection** 接收关键点，注入当前选定的 **SquatStrategy**。
    
4. **SquatStrategy** 计算角度并更新计数，返回分析结果。
    
5. **CameraOverlay** 读取结果，立即绘制骨骼与计数覆盖层（<100ms）。
    
6. **Telemetry Buffer** 异步缓存该结果。
    

### 5.3.3.2 场景二：智能训练总结生成

此场景展示了前后端及外部服务如何跨边界协作。

1. **App** 触发“结束训练”，调用 **SessionController**。
    
2. **SessionService** 调用 **Advisor Agent**。
    
3. **Advisor Agent** 构建 Prompt，HTTPS 请求 **智谱 AI**。
    
4. **智谱 AI** 返回建议文本，**Advisor Agent** 解析并存入对象。
    
5. **SessionService** 调用 **SessionRepository**，将统计数据与 AI 建议一并写入数据库。
    

## 5.3.4 系统装配与连接

各子系统通过标准的**连接器**进行物理装配。

### 5.3.4.1 客户端-服务器装配

- **连接器**：HTTPS 连接器。
    
- **通信契约**：JSON over HTTP/1.1。
    
- **机制**：前端 Axios 客户端配置拦截器，自动注入 JWT Token，与后端中间件对接实现无状态鉴权。
    

### 5.3.4.2 服务器-数据装配

- **连接器**：数据库连接池 (SQLAlchemy)。
    
- **机制**：后端维护 TCP 长连接池连接 PostgreSQL，复用连接以降低开销。
    

### 5.3.4.3 服务器-外部服务装配

- **连接器**：API 网关客户端。
    
- **机制**：后端作为 HTTP 客户端，通过 TLS 加密通道调用智谱 AI 开放接口。
    

## 5.3.5 组合结构图

在理解了各个孤立的子系统后，我们需要从全局视角观察它们的**装配关系**。本图通过黑盒视角展示了前端、后端与外部 SaaS 服务之间的物理连接点与数据吞吐边界。
![系统组合结构图](./pictures/Pasted%20image%20251226220240.png)
> **[此处插入图表 5-6：系统组合结构图 (UML Composition Structure Diagram)]** **绘图说明**：这是一张全景图。左侧画前端大框（包含 MediaPipe, React 组件），右侧画后端大框（包含 Flask, TF Engine, Agent），底部画数据库。用箭头把它们连起来，标注数据流向。

图5-7 系统组合结构图
## 5.3.6 设计基本原理

本组合视图的设计决策基于以下权衡：

1. **为什么将姿态推理放在前端？** 为了满足 **<100ms 实时反馈** 的非功能性需求。视频流网络传输延迟不可控，只有在边缘端（浏览器）处理才能消除网络瓶颈，同时规避上传用户原始视频的**隐私合规风险**。
    
2. **为什么后端还需要深度学习引擎？** 前端受限于浏览器算力，只能运行轻量级模型。后端引入 TensorFlow 引擎用于**异步复核**，处理前端难以判断的复杂边界情况，实现“速度”与“精度”的平衡。
    
3. **为什么使用 PostgreSQL JSONB 存储？** 运动数据具有高度**多态性**。深蹲的数据结构与平板支撑完全不同。JSONB 允许在同一张表中存储异构的遥测数据，避免了频繁的表结构变更。
    

## 5.3.7 部署单元

系统物理上映射为以下三个独立的可执行单元：

![部署单元架构图](./pictures/Pasted%20image%20251226220340.png)

1. **前端部署单元**：React 编译后的静态资源包 (HTML/CSS/JS/WASM)，部署至 Nginx 或 CDN。
    
2. **后端部署单元**：Docker 容器镜像（包含 Python 环境、Flask 应用、TensorFlow 运行时及模型文件），部署至云服务器。
    
3. **数据部署单元**：PostgreSQL 数据库实例。

# 5.4 逻辑视角 

逻辑视角关注系统的静态结构与功能抽象。本节通过类图和包图，定义了 FitnessAI 系统的核心领域实体、接口契约及类之间的静态关系，旨在揭示系统如何通过面向对象设计原则（如多态、封装）来实现 SRS 中的业务需求。

## 5.4.1 领域对象模型 

领域模型定义了系统内流转的核心业务实体及其关系。这些实体在数据库中持久化，并在前后端通过 JSON 序列化进行传输。

![核心领域类图](./pictures/Pasted%20image%20251226221742.png)
图5-8：核心领域类图
### 核心实体定义

1. **User (用户聚合根)**：系统的核心主体。不仅包含基础属性，还通过聚合关系管理其拥有的训练计划与历史会话。
    
2. **Session (训练会话)**：一次完整的运动记录。它是数据密度最高的实体，属性 `telemetry_data` 封装了时序性的骨骼坐标流。
    
3. **Exercise (运动元数据)**：定义了“深蹲”、“开合跳”等运动的标准参数（如 ID、名称、难度系数），属于系统的静态配置数据。
    
4. **TrainingPlan (训练计划)**：由 AI 生成的指导性实体，包含周期性的训练目标。
    

## 5.4.2 前端分析逻辑设计 

前端不仅是 UI，还承载了核心的**实时分析逻辑**。为了支持多种运动类型（深蹲、平板支撑等）并遵循**开闭原则 (OCP)**，系统采用了**策略模式 (Strategy Pattern)**。

![前端分析策略模式类图](./pictures/Pasted%20image%20251226221852.png)
图5-9：前端分析策略模式类图
### 设计模式应用：策略模式

- **上下文 : `PoseDetectionController`。它不关心具体的运动细节，只负责将 MediaPipe 的数据流转发给当前选定的策略。
    
- **抽象策略 : `IMotionStrategy`。定义了统一契约方法 `analyze(frame: Keypoints) -> AnalysisResult`。
    
- **具体策略:
    
    - `SquatStrategy`: 实现了基于几何角度（髋膝角 < 90°）的深蹲计数与纠错算法。
        
    - `PlankStrategy`: 实现了基于身体直线度（头-髋-踝共线）的静态计时算法。
        
- **工厂 (Factory)**: `StrategyFactory`。根据用户在 UI 选择的运动类型，动态实例化对应的策略类。
    

## 5.4.3 后端服务分层设计 

后端遵循**领域驱动设计 (DDD)** 的分层思想，将业务逻辑与基础设施解耦。


![后端服务分层类图](./pictures/Pasted%20image%20251226221917.png)
图 5-10 后端服务分层类图
### 分层逻辑详解

1. **控制器层 : `SessionController`。负责 HTTP 请求的解析与验证 (Pydantic Models)，不包含业务逻辑。
    
2. **应用服务层 **:
    
    - `SessionService`: 编排层。负责协调 `Repository` 进行存储，并调用 `AdvisorAgent` 获取 AI 建议。
        
    - `ScoringEngine`: 领域服务。包含复杂的评分算法（如基于方差的动作稳定性计算）。
        
3. **基础设施层:
    
    - `SessionRepository`: 实现数据库访问接口。
        
    - `ZhipuAIClient`: 封装 HTTP 调用细节，处理重试与鉴权。

### 5.4.4 深度学习推理模块设计

本模块负责后端高精度动作分析的实现。它将非结构化的骨骼关键点转化为数学特征向量，并输入预训练的神经网络模型获取状态概率。


![深度学习模块类图](./pictures/Pasted%20image%20251226222246.png)
图5-11：深度学习模块类图

#### 核心类定义

1. **SquatClassifier (推理包装器)**
    
    - **职责**：封装 TensorFlow/Keras 运行时环境。
        
    - **关键特性**：通常设计为**单例 (Singleton)**，以避免频繁加载大模型文件（`.h5`）导致的内存开销和延迟。它负责将模型的概率输出（如 `[0.1, 0.8, 0.1]`）转化为具体的枚举状态。
        
2. **FeatureExtractor (特征工程工具)**
    
    - **职责**：纯函数静态工具类。
        
    - **逻辑**：它不包含业务状态，仅负责执行向量数学运算。例如，计算 Hip-Knee-Ankle 的三维夹角、计算脊柱的垂直倾角等，最终输出一个 **24 维特征向量** 供模型消费。
        
3. **SquatState (状态枚举)**
    
    - 定义了模型的分类结果集：`STANDING` (站立), `DESCENDING` (下蹲过程), `BOTTOM` (底部), `ASCENDING` (起立过程)。




# 5.5 依赖视角 

依赖视角描述了 FitnessAI 系统中各设计实体（子系统、模块、组件）之间的**使用（Uses）**、**包含（Includes）**和**部署（Deploys）**关系。本节旨在明确系统的耦合程度，识别关键路径上的外部依赖，并为后续的维护与变更影响分析提供依据。

## 5.5.1 模块间依赖原则

FitnessAI 遵循**“单向依赖”**与**“依赖倒置 (DIP)”**的设计原则，严格控制模块间的耦合方向。

### 5.5.1.1 前端子系统依赖链

前端采用 MVVM 变体架构，依赖流向严格从视图层指向逻辑层，再指向基础设施层。

* **View (UI)**  **ViewModel (Hooks)**: `CameraView` 依赖 `usePoseDetection` 提供的数据流。UI 是易变的，但逻辑是相对稳定的。
* **ViewModel**  **Domain (Strategy)**: `usePoseDetection` 依赖抽象接口 `IMotionStrategy`，而不直接依赖具体的 `SquatStrategy` 类（通过工厂模式解耦）。
* **Infrastructure**  **External Libs**: `MediaPipeAdapter` 直接依赖 `@mediapipe/pose` 库。这是系统的**防腐层 (ACL)**，防止外部库的变更扩散到业务逻辑中。

### 5.5.1.2 后端子系统依赖链

后端采用分层架构，遵循自上而下的严格调用依赖。

* **Controller Layer**  **Service Layer**: 接口层仅负责路由与参数解析，依赖业务层执行逻辑。
* **Service Layer**  **Domain Layer**: 业务层依赖 `PoseAnalyzer` 和 `SquatClassifier` 等核心领域对象。
* **Service Layer**  **Repository Layer (Interface)**: 业务层依赖数据访问接口（`ISessionRepository`），而非具体的 SQL 实现，确保了数据库技术的可替换性。

## 5.5.2 外部技术栈依赖

系统对第三方组件、库及运行时环境存在强依赖。为确保系统的可构建性（Buildability），以下表格列出了核心依赖及其版本约束。

### 5.5.2.1 前端运行时依赖

| 依赖组件 | 版本约束 | 关键性 | 变更风险 | 说明 |
| --- | --- | --- | --- | --- |
| **MediaPipe Pose** | `^0.10.0` | **Critical** | High | 核心姿态识别库。API 变更将直接导致 `MediaPipeAdapter` 重构。 |
| **TensorFlow.js** | `^4.10.0` | High | Medium | 用于前端轻量级推理（如需）。 |
| **React** | `^18.2.0` | High | Low | UI 框架。依赖其并发渲染特性（Concurrent Mode）。 |
| **Browser WebRTC** | W3C Standard | **Critical** | Low | 依赖 `navigator.mediaDevices`。需关注 Safari/Chrome 的实现差异。 |

### 5.5.2.2 后端运行时依赖

| 依赖组件 | 版本约束 | 关键性 | 变更风险 | 说明 |
| --- | --- | --- | --- | --- |
| **TensorFlow (Py)** | `2.14.x` | **Critical** | High | 深度学习运行时。版本需与训练出的 `.h5` 模型文件兼容。 |
| **Flask** | `^2.3.0` | High | Low | Web 框架。 |
| **SQLAlchemy** | `^2.0.0` | High | Medium | ORM 框架。JSONB 字段的操作依赖其特定扩展。 |
| **Zhipu AI SDK** | `^4.0.0` | Medium | Medium | 外部大模型服务。依赖智谱 OpenAPI 规范。 |

## 5.5.3 变更影响分析

基于上述依赖关系，本节分析关键组件变更时的**波及范围 (Ripple Effect)**。

### 5.5.3.1 场景 A：MediaPipe 库升级

* **触发条件**：Google 发布 MediaPipe 新版本（如 v0.11），更改了关键点的数据结构（如新增了手指节点）。
* **直接影响**：前端 `MediaPipeAdapter` 必须修改以适配新接口。
* **间接影响**：
* `FeatureExtractor` 可能需要更新关键点索引映射。
* 后端 `SquatClassifier` 的输入维度若发生变化，需要重新训练模型。


* **控制策略**：依赖关系终止于 Adapter 层。业务逻辑层（Strategy）通过统一的数据接口与 Adapter 交互，因此**无需修改**。

### 5.5.3.2 场景 B：增加新的运动类型（如“波比跳”）

* **触发条件**：产品需求新增运动支持。
* **影响范围**：
* **前端**：新增 `BurpeeStrategy` 类（实现 `IMotionStrategy` 接口）；`StrategyFactory` 增加分支。UI 层 `ExerciseSelector` 增加选项。
* **后端**：新增 `BurpeeAnalyzer`；数据库 `exercises` 表新增元数据。


* **结论**：由于采用了**策略模式**和**工厂模式**，变更仅涉及新增类，符合**开闭原则 (OCP)**，不会破坏现有代码稳定性。

### 5.5.3.3 场景 C：从 PostgreSQL 迁移至 MongoDB

* **触发条件**：非结构化数据量激增，需切换数据库。
* **影响范围**：
* 仅影响后端 **Repository Layer** (`PostgresSessionRepo`) 的实现。
* Controller 层和 Service 层依赖的是 `ISessionRepository` 接口，因此**完全不受影响**。



## 5.5.4 依赖关系图

下图展示了 FitnessAI 系统中模块级和组件级的依赖层级。箭头方向表示  即“A 依赖 B”（A import B 或 A call B）。
![依赖关系图](./pictures/Pasted%20image%20251227014401.png)
图5-12：依赖关系图

# 5.6 信息视角 

信息视角关注系统持久化数据的组织方式、存储策略及生命周期管理。基于 **5.3 节** 定义的数据子系统架构，FitnessAI 采用 **PostgreSQL 对象-关系型数据库**，通过混合存储模式平衡业务事务的一致性需求与 AI 遥测数据的多态性需求。

## 5.6.1 数据持久化策略 

系统依据数据的性质采用分级存储策略：

1. **强一致性数据**（如用户账号）：采用标准关系型表，严格遵循第三范式 (3NF)。
    
2. **高吞吐时序数据**（如 `telemetry_log`）：采用 **JSONB** 字段存储，利用 PostgreSQL 的 **GIN 索引** 支持对 JSON 内部字段的高效查询。
    
3. **非持久化数据**（如原始视频流）：**内存级处理，不落盘**。
    

## 5.6.2 数据模式规约

### 5.6.2.1 物理模型设计
下图是 5.3 ER 图的物理实现版。展示具体的字段类型（UUID, VARCHAR, TIMESTAMPTZ, JSONB）、主外键约束及索引设计。
![数据库物理模型图](./pictures/Pasted%20image%20251227022131.png)
图5-13：数据库物理模型图
**关键表定义**：

|**表名 (Table)**|**核心字段**|**类型**|**约束/索引**|**说明**|
|---|---|---|---|---|
|**users**|`user_id`|UUID|PK|用户唯一标识|
||`email`|VARCHAR|Unique Index|登录账号|
||`profile`|JSONB|-|包含身高(cm)、体重(kg)、性别|
|**sessions**|`session_id`|UUID|PK|训练会话 ID|
||`telemetry_log`|JSONB|**GIN Index**|核心：动作遥测日志（详见 5.6.3）|
||`ai_feedback`|JSONB|-|智谱 AI 生成的建议|
|**exercises**|`code`|VARCHAR|Unique|如 'squat', 'plank'|
||`config`|JSONB|-|运动特定的阈值配置（如标准膝角）|
### 5.6.2.2 JSONB 文档结构

由于 JSONB 缺乏数据库层面的 Schema 强制校验，本设计文档必须明确其**隐式 Schema**。

#### A. 遥测日志结构 (`sessions.telemetry_log`)

存储一次训练中所有关键帧的快照。系统不存储每一帧（30fps），仅存储**关键动作帧**（如深蹲到底部时）或按固定时间窗口降采样的数据。

JSON

```
{
  "version": "1.0",
  "sampling_rate": "500ms", // 采样频率
  "timeline": [
    {
      "timestamp": 12050,       // 相对开始时间的毫秒数
      "rep_count": 5,           // 当前完成次数
      "is_correct": false,      // 本次动作是否标准
      "faults": ["knee_valgus"],// 错误类型标签
      "metrics": {              // 运动特定的动态指标
        "knee_angle_left": 85.5,
        "hip_depth": 0.45
      },
      "landmarks_snapshot": [   // 33个关键点的归一化坐标 (压缩存储)
        [0.55, 0.65, 0.1],      // [x, y, z]
        ...
      ]
    }
  ]
}
```

#### B. AI 反馈结构 (`sessions.ai_feedback`)

存储智谱 AI 返回的结构化建议，用于前端展示富文本报告。

JSON

```
{
  "generated_at": "2023-12-20T10:00:00Z",
  "model_version": "glm-4",
  "summary_text": "今天的深蹲深度非常标准，但在后半程出现了轻微的膝盖内扣。",
  "improvement_plan": [
    {"target": "gluteus_medius", "action": "crab_walk", "reps": "3x15"}
  ],
  "score_breakdown": {
    "stability": 8.5,
    "rhythm": 9.0
  }
}
```

### 5.6.2.3 索引设计与查询优化 (Indexing & Optimization)

为确保在百万级数据量下的查询性能（响应时间 < 200ms），系统采用复合索引策略。

**1. GIN 倒排索引**

- **目标字段**：`sessions.telemetry_log`
    
- **策略**：创建 `jsonb_path_ops` 类型的 GIN 索引，支持对 JSON 内部任意键值的快速检索。
    
- **应用场景**：查询包含特定错误类型（如 "knee_valgus"）的所有会话。
    

**2. 表达式索引 **

- **目标**：针对高频查询路径（Hot Paths）创建预计算索引，避免运行时解析 JSON。
    
- **示例 SQL**：
    
    SQL
    
    ```
    -- 加速查询“完成次数”大于 10 的记录
    CREATE INDEX idx_sessions_rep_count ON sessions 
    (((telemetry_log->'metrics'->>'total_reps')::int));
    ```
    

**3. 常规 B-Tree 索引**

- **`users.email`**：唯一索引，加速登录鉴权。
    
- **`sessions.user_id` + `sessions.created_at`**：复合索引，加速“用户历史记录”的分页查询。
    

## 5.6.3 数据生命周期与归档

数据流转遵循“采集-缓冲-活跃-归档”的生命周期。 
![数据生命周期状态图](./pictures/Pasted%20image%20251227022639.png)

图5-14：数据生命周期状态图
**分级存储与归档策略**：

- **热数据 (Hot)**：最近 1 年的数据存储在主表 `sessions` 中，提供毫秒级读写。
    
- **冷数据 (Cold)**：超过 1 年的数据自动迁移至 `sessions_archive` 分区表（Partition Table）。
    
- **空间优化**：归档时执行 **ETL 清洗**，保留统计指标（Metrics），但移除占用空间巨大的 `landmarks_snapshot`（骨骼关键点快照），预计节省 80% 存储空间。
    

## 5.6.4 数据迁移与版本管理 (Migration & Versioning)

鉴于 JSONB 数据的灵活性，系统采用 **Schema-on-Read** 策略配合工具管理变更。

**1. Schema 演进策略

- **向后兼容**：新增字段时，旧数据视为 `null`，应用层需做好空值处理。
    
- **软废弃**：字段废弃时，保留历史数据但标记为 `deprecated`，不执行物理删除以保障历史回溯能力。
    

**2. 迁移工具链**

- **工具**：使用 **Alembic** (Python) 管理数据库 Schema 版本。
    
- **回滚机制**：所有迁移脚本（Migration Scripts）必须包含对应的 `upgrade()` 和 `downgrade()` 方法，确保发布失败时可无损回滚。
    

## 5.6.5 数据安全与隐私保护 

系统严格遵循“隐私设计 (Privacy by Design)”原则，确保符合 SRS 中的合规性要求。

**1. 字段级加密**

- **敏感信息**：`users.profile` 中的身高、体重等生物指标，在应用层使用 AES-256 加密后存入数据库，密钥由密钥管理服务（KMS）独立保管。
    

**2. 最小化脱敏 (Anonymization)**

- **AI 交互**：后端 Advisor Agent 在调用智谱 AI 接口前，执行**动态脱敏**，移除所有 PII（个人身份信息），仅发送统计类数据（如“膝盖角度偏差值”），确保第三方无法反向追踪用户。
    

**3. 数据保留策略 (Retention)**

- **主动注销**：用户注销账号后，系统启动 **30 天冷冻期**，期满后物理删除所有关联的 `users` 及 `sessions` 记录（硬删除）。


# 5.7 设计模式使用视角 

本视角描述了 FitnessAI 系统在解决特定设计问题时所采用的标准设计模式。系统遵循“面向接口编程”与“组合优于继承”的原则，广泛应用了 **GoF 设计模式**，以提高代码的可维护性、可扩展性及对第三方库的解耦能力。

## 5.7.1 模式应用汇总 

下表总结了系统中的核心设计模式及其在 FitnessAI 中的具体落地场景：

| **模式类别** | **模式名称**                  | **应用组件 (Context)**     | **解决的问题 **                                                                                               |
| -------- | ------------------------- | ---------------------- | -------------------------------------------------------------------------------------------------------- |
| **行为型**  | **策略模式 (Strategy)**       | 前端 `MotionAnalyzer`    | **问题**：深蹲和开合跳的计算逻辑完全不同，`if-else` 难以维护。<br><br>  <br><br>**方案**：定义 `IMotionStrategy` 接口，动态切换算法实现。         |
| **行为型**  | **观察者模式 (Observer)**      | 前端 `StatsDashboard`    | **问题**：高频（30fps）分析结果需要驱动 UI 刷新，但逻辑层不应持有 UI 引用。<br><br>  <br><br>**方案**：UI 组件订阅数据流，实现松耦合的实时渲染。            |
| **结构型**  | **适配器模式 (Adapter)**       | 前端 `MediaPipeAdapter`  | **问题**：`@mediapipe/pose` 库接口复杂且易变。<br><br>  <br><br>**方案**：建立防腐层（ACL），统一转换为系统内部的标准数据结构。                  |
| **创建型**  | **工厂方法 (Factory Method)** | 前端 `StrategyFactory`   | **问题**：创建具体的策略对象需要复杂的初始化参数。<br><br>  <br><br>**方案**：封装实例化逻辑，只需传入 `exerciseType` 即可获取对应策略。                |
| **创建型**  | **单例模式 (Singleton)**      | 后端 `SquatClassifier`   | **问题**：TensorFlow 模型文件大，加载慢。<br><br>  <br><br>**方案**：确保全局仅有一个模型实例，避免内存溢出。                                |
| **结构型**  | **外观模式 (Facade)**         | 后端 `ZhipuAIClient`     | **问题**：调用智谱 AI 需要处理 Token、Prompt 组装、重试等繁琐细节。<br><br>  <br><br>**方案**：提供简单的 `generate_advice()` 接口供业务层调用。 |
| **架构模式** | **仓储模式 (Repository)**     | 后端 `SessionRepository` | **问题**：JSONB 索引查询语法复杂，污染业务代码。<br><br>  <br><br>**方案**：在仓储层封装 SQL 细节，向 Service 层暴露语义化接口。                  |

## 5.7.2 核心模式详解

### 5.7.2.1 策略与工厂模式 (Strategy & Factory)

这是系统前端**实时分析引擎**的核心设计。通过策略模式实现算法的**可替换性**，通过工厂模式实现对象的**可创建性**。


![运动分析策略模式类图](./pictures/Pasted%20image%20251227023822.png)
图表 5-15：运动分析策略模式类图 

### 5.7.2.2 适配器模式 (Adapter)

作为系统的**防腐层 (Anti-Corruption Layer)**，`MediaPipeAdapter` 隔离了外部算法库的变化。

- **Target**: `detect(image): UnifiedLandmarks`
    
- **Adaptee**: `MediaPipe.Pose.send()` / `onResults()`
    
- **价值**：即使未来更换为 YOLOv8-Pose，只需重写适配器，上层业务逻辑（策略层）无需任何修改。
    

### 5.7.3 设计权衡 (Trade-offs)

在使用模式时，系统进行了以下权衡：

1. **避免过度工程**：对于简单的 CRUD 业务（如用户资料修改），系统直接在 Service 层实现，未引入命令模式（Command Pattern），保持了代码的简洁性。
    
2. **性能考量**：在前端高频（30fps）渲染循环中，避免频繁创建销毁对象。策略对象在切换运动时**惰性加载（Lazy Loading）**并复用，以减少垃圾回收（GC）压力。